'''Тема урока: матрицы
Работа с матрицами
Квадратные и прямоугольные матрицы
Функции ljust() и rjust()
Главная и побочная диагонали
Аннотация. Урок посвящен работе с матрицами — прямоугольными таблицами.

Матрицы
В прошлых уроках мы изучили вложенные списки, то есть списки, входящие в качестве элементов в другие списки. Частный
 случай вложенных списков — матрицы — прямоугольные таблицы, заполненные какими-то значениями, обычно числами.



Матрицы часто применяются в математике, так как многие задачи с их помощью гораздо проще сформулировать, записать
и решить.

Для работы с матрицами нужно уметь получать элемент ii-й строки jj-го столбца. Для этого обычно заводят список строк
матрицы, где каждая строка — список элементов. Получается вложенный список или список списков. Теперь, чтобы получить
определенный элемент, достаточно из списка строк матрицы выбрать ii-ю и взять jj-й элемент этой строки.

Давайте заведем матрицу размера 3×4 (3 строки и 4 столбца), содержащую числа, и получим элемент на позиции
(2, 3)(2, 3), то есть элемент второй строки в третьем столбце.

matrix  = [[2, -5, -11, 0],
           [-9, 4, 6, 13],
           [4, 7, 12, -2]]

print(matrix[1][2])  # вывод элемента на позиции (2, 3)
В переменной matrix — хранится вся матрица, при этом matrix[1] — список значений во второй строке, matrix[1][2] —
элемент в третьем столбце этой строки.



В математике нумерация строк и столбцов начинается с единицы, а не с нуля. По договоренности сначала всегда
указывается строка, а затем — столбец. Элемент на ii-ой строке, jj-м столбце матрицы aa обозначается так a_{ij}a
ij
​
 .

Перебор элементов матрицы
Чтобы перебрать элементы матрицы, необходимо использовать вложенные циклы. Например, выведем на экран все элементы
матрицы, перебирая их по строкам:

rows, cols = 3, 4           # rows - количество строк, cols - количество столбцов

matrix  = [[2, 3, 1, 0],
           [9, 4, 6, 8],
           [4, 7, 2, 7]]

for r in range(rows):
    for c in range(cols):
        print(matrix[r][c], end=' ')
    print()
Результатом работы такого кода будет:

2 3 1 0
9 4 6 8
4 7 2 7
Для перебора элементов матрицы по столбцам можно использовать следующий код:

rows, cols = 3, 4           # rows - количество строк, cols - количество столбцов

matrix  = [[2, 3, 1, 0],
           [9, 4, 6, 8],
           [4, 7, 2, 7]]

for c in range(cols):
    for r in range(rows):
        print(matrix[r][c], end=' ')
    print()
Результатом работы такого кода будет:

2 9 4
3 4 7
1 6 2
0 8 7
Функции ljust() и rjust()
Рассмотрим программный код:

rows, cols = 3, 4                # rows - количество строк, cols - количество столбцов

matrix  = [[277, -930, 11, 0],
           [9, 43, 6, 87],
           [4456, 8, 290, 7]]

for r in range(rows):
    for c in range(cols):
        print(matrix[r][c], end=' ')
    print()
 Результатом работы такого кода будет:

277 -930 11 0
9 43 6 87
4456 8 290 7
Выведенная матрица не сильно похожа на упорядоченный прямоугольник. Элементы матрицы имеют разное количество
разрядов и результат вывода получается смазанным. Для решения проблемы удобно использовать строковые методы
ljust() и rjust().

Метод ljust()
Строковый метод ljust() выравнивает текст по ширине, добавляя пробелы в конец текста.

Результатом выполнения следующего кода:

print('a'.ljust(3))
print('ab'.ljust(3))
print('abc'.ljust(3))
будет:

a⎵⎵
ab⎵
abc
Исходная строка не обрезается, даже если в ней больше символов, чем нужно.

Результатом выполнения следующего кода:

print('abcdefg'.ljust(3))
будет:

abcdefg
Строковый метод ljust() использует вместо пробела другой символ, если передать ему второй аргумент, необязательный.

Результатом выполнения следующего кода:

print('a'.ljust(5, '*'))
print('ab'.ljust(5, '$'))
print('abc'.ljust(5, '#'))
будет:

a****
ab$$$
abc##
Метод rjust()
Строковый метод rjust() выравнивает текст по ширине, добавляя пробелы в начало текста.

Результатом выполнения следующего кода:

print('a'.rjust(3))
print('ab'.rjust(3))
print('abc'.rjust(3))
будет:

⎵⎵a
⎵ab
abc
Исходная строка не обрезается, даже если в ней больше символов, чем нужно.

Результатом выполнения следующего кода:

print('abcdefg'.rjust(3))
будет:

abcdefg
Строковый метод rjust() использует вместо пробела другой символ, если передать ему второй аргумент, необязательный.

Результатом выполнения следующего кода:

print('a'.rjust(5, '*'))
print('ab'.rjust(5, '$'))
print('abc'.rjust(5, '#'))
будет:

****a
$$$ab
##abc
Применив метод ljust() для выравнивания столбцов при выводе таблицы мы получим следующий код:

rows, cols = 3, 4                # rows - количество строк, cols - количество столбцов

matrix  = [[277, -930, 11, 0],
           [9, 43, 6, 87],
           [4456, 8, 290, 7]]

for r in range(rows):
    for c in range(cols):
        print(str(matrix[r][c]).ljust(6), end='')
    print()
Результатом выполнения такого кода будет:

277   -930  11    0
9     43    6     87
4456  8     290   7
Квадратные матрицы
Матрица с одинаковым количеством строк и столбцов называется квадратной. У квадратной матрицы есть две диагонали:

главная: проходит из верхнего левого в правый нижний угол матрицы;
побочная: проходит из нижнего левого в правый верхний угол матрицы.


Элементы с равными индексами i == j находятся на главной диагонали. Такие элементы обозначаются matrix[i][i].

Элементы с индексами i и j, связанными соотношением i + j + 1 = n (или j = n - i - 1), где n — размерность матрицы,
находятся на побочной диагонали.

Таким образом, чтобы установить элементы главной или побочной диагонали, достаточно одного цикла.

Результатом выполнения следующего кода:

n = 8
matrix = [[0]*n for _ in range(n)]    # создаем квадратную матрицу размером 8×8

for i in range(n):                     # заполняем главную диагональ 1-цами, а побочную 2-ками
    matrix[i][i] = 1
    matrix[i][n-i-1] = 2

for r in range(n):                     # выводим матрицу
    for c in range(n):
        print(matrix[r][c], end=' ')
    print()
будет:

1 0 0 0 0 0 0 2
0 1 0 0 0 0 2 0
0 0 1 0 0 2 0 0
0 0 0 1 2 0 0 0
0 0 0 2 1 0 0 0
0 0 2 0 0 1 0 0
0 2 0 0 0 0 1 0
2 0 0 0 0 0 0 1
Индексыi и jэлементов на главной диагонали связаны соотношением i = j. Индексы i и jэлементов на побочной диагонали
связанны соотношением i + j + 1 = n (или  j = n - i - 1), где n — размерность матрицы

Заметим также, что:

если элемент находится выше главной диагонали, то i < j, если ниже, i > j.
если элемент находится выше побочной диагонали, то i + j + 1 < n, если ниже, i + j + 1 > n.
Примечания
Примечание 1. Чтобы понять, в какой области лежит элемент можно воспользоваться следующей картинкой.



Примечание 2. Используйте функцию print_matrix() для вывода квадратной матрицы размерности n:

def print_matrix(matrix, n, width=1):
    for r in range(n):
        for c in range(n):
            print(str(matrix[r][c]).ljust(width), end=' ')
        print()
Примечание 3. Для считывания квадратной матрицы размерности n, заполненной числами, удобно использовать следующий код:

n = int(input())
matrix = []
for i in range(n):
    temp = [int(num) for num in input().split()]
    matrix.append(temp)'''
'''Вывести матрицу 1
На вход программе подаются два натуральных числа nn и mm, каждое на отдельной строке — количество строк и столбцов в матрице. Далее вводятся сами элементы матрицы — слова, каждое на отдельной строке; подряд идут элементы сначала первой строки, затем второй, и т.д.

Напишите программу, которая сначала считывает элементы матрицы один за другим, затем выводит их в виде матрицы.

Формат входных данных
На вход программе подаются два числа nn и mm — количество строк и стобцов в матрице, далее идут n \times mn×m слов, каждое на отдельной строке.

Формат выходных данных
Программа должна вывести считанную матрицу, разделяя ее элементы одним символом пробела.

Sample Input 1:

4
2
и
швец
и
жнец
и
на
дуде
игрец
Sample Output 1:

и швец
и жнец
и на
дуде игрец
Sample Input 2:

2
3
язык
болтает
а
голова
не
знает
Sample Output 2:

язык болтает а
голова не знает'''
# rows = int(input())
# cols = int(input())
#
# for i in range(rows):
#     line = [input() for _ in range(cols)]
#     if i != 0 and i != rows-1:
#         print(*line)
#     else:
#         print(*line)
#

# m, n, s = int(input()), int(input()), []
# [s.append(input()) for i in range(m * n)]
# for i in range(0, len(s), n):
#     print(* s[i : i + n], sep = ' ')


# print((lambda n, m: "\n".join(" ".join(input() for _ in range(m)) for _ in range(n)))(int(input()), int(input())))


# n = int(input())
# m = int(input())
#
# for i in range(n):
#     line = [input() for _ in range(m)]
#     if i != 0 and i != n-1:
#         print(*line)
#     else:
#         print(*line)
# print()
# res = [[None for j in range(n)] for i in range(m)]
#
# for i in range(n):
#     for j in range(m):
#         res[j][i] = input()
#
# for row in res:
#     print(*row)
# *************************************************************************************
n = int(input())
m = int(input())
# s = input()

res1 = [[None for j in range(m)] for i in range(n)]

for i in range(n):
    for j in range(m):

        res1[i][j] = input()

for row in res1:
    print(*row)

print()
res = [[None for j in range(n)] for i in range(m)]

for i in range(n):
    for j in range(m):
        res[j][i] = res1

for row in res:
    print(*row)

# *********************************************************************************************
'''Тема урока: модуль decimal
Числа с плавающей точкой float
Модуль decimal
Тип данных Decimal
Аннотация. Урок посвящен модулю decimal и типу данных Decimal.

Числовые типы данных
В прошлых уроках мы изучили два числовых типа данных, представленных в Python:

int – целое число;
float – число с плавающей точкой (аналог вещественного числа в математике).
В Python есть три дополнительных числовых типа данных:

Decimal – десятичное число, для выполнения точных расчетов;
Fraction – число, представляющее собой обыкновенную дробь, с заданным числителем и знаменателем;
Complex – комплексное число.
В этом уроке мы изучим числовой тип данных Decimal, аналог типа данных float на случай более точных вычислений.

Тип данных float
Рассмотрим программный код:

if 0.3 == 0.3:
    print('YES')
else:
    print('NO')
Результатом выполнения такого кода будет как и полагается YES.

А теперь рассмотрим программный код:

num = 0.1 + 0.1 + 0.1

if num == 0.3:
    print('YES')
else:
    print('NO')
Вы будете удивлены, но результатом выполнения такого кода будет NO, так как на самом деле в переменной num хранится
 что-то типа 0.300000000000000040.30000000000000004.

Из-за ограничений в сохранении точного значения чисел, даже простейшие математические операции могут выдавать ошибочный
результат. Поэтому, чтобы сравнивать два float числа мы должны использовать такой код:

num = 0.1 + 0.1 + 0.1
eps = 0.000000001           # точность сравнения

if abs(num - 0.3) < eps:    # число num отличается от числа 0.3 менее чем 0.000000001
    print('YES')
else:
    print('NO')
Такой код выводит, как полагается, значение YES.

Не стоит сравнивать float числа с помощью оператора ==. Для сравнения float чисел нужно использовать указанный выше код.

Тип данных Decimal
Тип данных Decimal – это класс из стандартного модуля decimal. Он представляет собой число с плавающей точкой, как и
float. Однако, Decimal имеет ряд существенных отличий от float.

Тип Decimal создан, чтобы операции над вещественными числами в компьютере выполнялись как в математике, и равенство
 0.1 + 0.1 + 0.1 == 0.30.1+0.1+0.1==0.3 было верным.

Точность результатов арифметических действий очень важна для научных вычислений, в сфере финансов и бизнеса. Для таких
 задач тип данных float не подходит.

В Python тип данных float реализован по стандарту IEEE-754 как число с плавающей точкой двойной точности (6464 бита)
с основанием экспоненты равным 22. Реализация таких чисел заложена прямо в железо любого современного процессора.
 Поэтому float в Python работает как аналогичный тип данных double в таких языках программирования как С#, С++, Java
  и т.д. И имеет такие же ограничения и «странности». Так как float поддерживается аппаратно, быстродействие при
  использовании этого типа данных сравнительно велико.

Тип данных Decimal – число с плавающей точкой с основанием экспоненты 1010. Он реализован по стандарту IBM: General
Decimal Arithmetic Specification, в свою очередь основанному на стандартах IEEE.

Тип данных Decimal реализован программно, поэтому он в разы медленнее типа данных float, реализованного аппаратно. Сам
тип данных Decimal написан на языке С.

Тип данных Decimal оперирует числами с произвольной – задаваемой программистом, но конечной точностью. По умолчанию
точность составляет 2828 десятичных знаков.

Тип данных Decimal неизменяемый. Операции над ним приводят к созданию новых объектов, при этом старые не меняются.

Еще одно следствие того, что Decimal реализован программно – его можно на ходу настраивать, как угодно программисту.
Для этого есть контекст – объект, содержащий настройки для выполнения операций. Операции, выполняемые в контексте,
 следуют заданным в нем правилам. Для float все правила фиксированы на аппаратном уровне.

Для типа данных Decimal можно настроить:

точность выполнения операций в количестве десятичных знаков;
режимы округления;
режимы обработки исключительных ситуаций (деление на ноль, переполнение и т. д).
Создание Decimal чисел
Создать Decimal число можно из обычного целого числа (int), из числа с плавающей точкой (float) или из строки (str).

Приведенный ниже программный код создает Decimal числа на основе целого числа и строки:

from decimal import *

d1 = Decimal(1)
d2 = Decimal(567)
d3 = Decimal(-93)
d4 = Decimal('12345')
d5 = Decimal('52.198')

print(d1, d2, d3, d4, d5, sep='\n')
и выводит:

1
567
-93
12345
52.198
При создании Decimal чисел из чисел с плавающей точкой (float) возникают проблемы, так как float числа округляются
внутри до ближайшего возможного, а Decimal об этом ничего не знает и копирует содержимое float.

Приведенный ниже программный код создает Decimal число на основе числа с плавающей точкой:

from decimal import *

num = Decimal(0.1)

print(num)
и выводит:

0.1000000000000000055511151231257827021181583404541015625
Не рекомендуется создавать Decimal числа из float чисел. В Decimal попадет уже неправильно округленное число. Создавать
Decimal числа нужно из целых чисел, либо из строк!

 Арифметические операции над Decimal числами
Тип данных Decimal отлично интегрирован в язык Python. С Decimal числами работают все привычные операции: сложение,
 вычитание, умножение, деление, возведение в степень.

Приведенный ниже код:

from decimal import *

num1 = Decimal('5.2')
num2 = Decimal('2.3')

print(num1 + num2)
print(num1 - num2)
print(num1 * num2)
print(num1 / num2)
print(num1 // num2)
print(num1 ** num2)
выводит:

7.5
2.9
11.96
2.260869565217391304347826087
2
44.34122533787992500412791298
Можно совершать арифметические операции над Decimal и целыми числами (миксовать Decimal и int), но не рекомендуется
смешивать их с float.

Приведенный ниже код:

from decimal import *

num = Decimal('5.2')

print(num + 1)
print(num - 10)
print(num * 2)
print(num ** 4)
выводит:

6.2
-4.8
10.4
731.1616
Математические функции
Decimal числа можно передавать как аргументы функциям, ожидающим float. Они будут преобразованы во float. К примеру,
 модуль math, оперирующий float числами, может работать и с Decimal числами.

Приведенный ниже код:

from decimal import *
from math import *

num1 = Decimal('1.44')
num2 = Decimal('0.523')

print(sqrt(num1))
print(sin(num2))
print(log(num1 + num2))
выводит:

1.2
0.4994813555186418
0.6744739152943241
Важно понимать, что результатом работы функции модуля math являются float числа, а не Decimal.

Тип данных Decimal содержит некоторые встроенные математические методы, возвращающие значения Decimal.

     Функция  	Описание
sqrt()	вычисляет квадратный корень из Decimal числа
exp()
возвращает e^xe
x
  для Decimal числа

ln()
вычисляет натуральный логарифм (по основанию ee) Decimal числа

log10()
вычисляет десятичный логарифм (по основанию 1010) Decimal числа

Приведенный ниже код:

from decimal import *

num = Decimal('10.0')

print(num.sqrt())
print(num.exp())
print(num.ln())
print(num.log10())
выводит:

3.162277660168379331998893544
22026.46579480671651695790065
2.302585092994045684017991455
1
Обратите внимание на количество знаков после запятой. Их 2727, что соответствует точности десятичного числа по
умолчанию.

Тип данных Decimal также содержит полезный метод as_tuple() который возвращает кортеж из 33 элементов:

sign – знак числа (00 для положительного числа и 11 для отрицательного числа);
digits – цифры числа;
exponent – значение экспоненты (количество цифр после точки, умноженное на -1−1),
Приведенный ниже код:

from decimal import *

num1 = Decimal('-1.4568769017')
num2 = Decimal('0.523')

print(num1.as_tuple())
print(num2.as_tuple())
выводит:

DecimalTuple(sign=1, digits=(1, 4, 5, 6, 8, 7, 6, 9, 0, 1, 7), exponent=-10)
DecimalTuple(sign=0, digits=(5, 2, 3), exponent=-3)
Приведенный ниже код:

from decimal import *

num = Decimal('-1.4568769017')
num_tuple = num.as_tuple()

print(num_tuple.sign)
print(num_tuple.digits)
print(num_tuple.exponent)
выводит:

1
(1, 4, 5, 6, 8, 7, 6, 9, 0, 1, 7)
-10
Работа с контекстом Decimal чисел
Базовые параметры Decimal можно посмотреть в его контексте, выполнив функцию getcontext().

Приведенный ниже код:

from decimal import *

print(getcontext())
выводит:

Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0,
flags=[], traps=[InvalidOperation, DivisionByZero, Overflow])
Мы видим здесь, что точность 2828 знаков, округление к ближайшему четному, пределы по экспоненте \pm 999999± 999999,
 capitals – это про заглавную Е при печати, включенные ловушки – неправильная операция, деление на ноль, переполнение.

Точность чисел
Контекстом в Decimal можно управлять, устанавливая свои значения. Например, чтобы управлять точностью Decimal,
необходимо изменить параметр контекста prec (от англ. precision – точность). При этом точность вступает в силу только
 во время арифметических операций, а не при создании самих чисел.

Приведенный ниже код:

from decimal import *

getcontext().prec = 3      # устанавливаем точность в 3 знака

num = Decimal('3.1415')

print(num)
print(num * 1)
print(num * 2)
print(num / 2)
выводит:

3.1415
3.14
6.28
1.57
Обратите внимание на то, что точность вступает в силу только во время арифметических операций, а не при создании самих
чисел.

Округление чисел
Округляют числа Decimal с помощью метода quantize(). Этот метод в качестве первого аргумента принимает объект Decimal,
 указывающий на формат округления.

Приведенный ниже код:

from decimal import *

getcontext().prec = 4                    # устанавливаем точность округления

num = Decimal('3.1415926535')

print(num.quantize(Decimal('1.000')))    #  округление до 3 цифр в дробной части
print(num.quantize(Decimal('1.00')))     #  округление до 2 цифр в дробной части
print(num.quantize(Decimal('1.0')))      #  округление до 1 цифр в дробной части
выводит:

3.142
3.14
3.1
Если точность округления установлена в 22 , а формат округления Decimal('1.00'), то возникнет ошибка.

Приведенный ниже код:

from decimal import *

getcontext().prec = 2                    # устанавливаем точность округления

num = Decimal('3.1415926535')

print(num.quantize(Decimal('1.00')))     #  округление до 2 цифр в дробной части
приводит к возникновению ошибки:

decimal.InvalidOperation: [<class 'decimal.InvalidOperation'>]
Чтобы избежать ее, необходимо поменять точность округления на 33 и больше.

Помимо первого параметра, метод quantize() принимает в качестве второго параметра стратегию округления:

ROUND_CEILING – округление в направлении бесконечности (Infinity);
ROUND_FLOOR – округляет в направлении минус бесконечности (- Infinity);
ROUND_DOWN – округление в направлении нуля;
ROUND_HALF_EVEN – округление до ближайшего четного числа, число 6.96.9 округлится не до 77, а до 66;
ROUND_HALF_DOWN – округление до ближайшего нуля;
ROUND_UP – округление от нуля;
ROUND_05UP – округление от нуля (если последняя цифра после округления до нуля была бы 0 или 5, в противном случае к
нулю).
Приведенный ниже код:

from decimal import *

num = Decimal('3.456')

print(num.quantize(Decimal('1.00'), ROUND_CEILING))
print(num.quantize(Decimal('1.00'), ROUND_FLOOR))
выводит:

3.46
3.45
Сравнение float и Decimal чисел
Выбор между типами данных Decimal и float – поиск компромисса в условиях конкретной задачи.

Если нужно считать очень много (симуляции, физика, графика, игры), имеет смысл отказаться от точности Decimal в пользу
скорости и компактности хранения данных float. В бизнесе и финансах считать приходится не так много, но делать это
нужно предельно точно, тут имеет смысл посмотреть в сторону Decimal.

Характеристика / тип	float	Decimal
Реализация	аппаратная	программная
Размер	6464 бит	не ограничен
Основание экспоненты	22	1010
Скорость	✔️	❌
Настраеваемость	❌	✔️
Для финансов и бизнеса	❌	✔️
Для симуляций, визуализаций и игр	✔️	❌
Для высокоточных вычислений	❌	✔️
Примечания
Примечание 1. Decimal числа можно сравнивать между собой, как обычные числа, причем в отличие от float чисел
 допускается и точное равенство.

from decimal import *

num = Decimal('0.1')
if num*3 == Decimal('0.3'):
    print('YES')
else:
    print('NO')
Примечание 2. Можно сортировать списки с Decimal числами и искать минимум и максимум среди них.

Приведенный ниже код:

from decimal import *

s = '1.34 3.45 1.00 0.03 9.25'

numbers = [Decimal(i) for i in s.split()]

maximum = max(numbers)
minimum = min(numbers)

numbers.sort()

print(maximum)
print(minimum)
print(numbers)
выводит:

9.25
0.03
[Decimal('0.03'), Decimal('1.00'), Decimal('1.34'), Decimal('3.45'), Decimal('9.25')]
Примечание 3. Подробнее о типе данных Decimal можно почитать в официальной документации тут, тут и тут.

Примечание 4. Подробная статья об устройстве float чисел на хабре.

Примечание 5. О стандарте Decimal чисел от IBM можно почитать тут.

Примечание 6. Чтобы не писать каждый раз название типа, можно использовать следующий код:

from decimal import Decimal as D

num1 = D('1.5') + D('3.2')
num2 = D('1.4') * D('2.58')

print(num1)
print(num2)'''


'''Decimal числа, разделенные символом пробела, хранятся в строковой переменной s. Дополните приведенный код, чтобы
 он вывел сумму наибольшего и наименьшего Decimal числа.'''


# from decimal import Decimal
#
# s = list('0.77 4.03 9.06 3.80 7.08 5.88 0.23 4.65 2.79 0.90 4.23 2.15 3.24 8.57 0.10 8.57 1.49 5.64 3.63 8.36 1.56 '
#          '6.67 1.46 5.26 4.83 7.23 1.22 1.02 7.82 9.97 5.40 9.79 9.82 2.78 2.96 0.07 1.72 7.24 7.84 9.23 1.71 6.24'
#          ' 5.78 5.37 0.03 9.60 8.86 2.73 5.83 6.50'
#          .split())
# maX= max(s)
# miN=min(s)
#
# print(Decimal(maX)+Decimal(miN))


# from decimal import Decimal as D
#
# s = '0.77 4.03 9.06 3.80 7.08 5.88 0.23 4.65 2.79 0.90 4.23 2.15 3.24 8.57 0.10 8.57 1.49 5.64 3.63 8.36 1.56 6.67 1.46 5.26 4.83 7.23 1.22 1.02 7.82 9.97 5.40 9.79 9.82 2.78 2.96 0.07 1.72 7.24 7.84 9.23 1.71 6.24 5.78 5.37 0.03 9.60 8.86 2.73 5.83 6.50'
#
# nums = [D(x) for x in s.split()]
# print(min(nums) + max(nums))


# from decimal import Decimal as D
# s = '0.77 4.03 9.06 3.80 7.08 5.88 0.23 4.65 2.79 0.90 4.23 2.15 3.24 8.57 0.10 8.57 1.49 5.64 3.63 8.36 1.56 6.67 1.46 5.26 4.83 7.23 1.22 1.02 7.82 9.97 5.40 9.79 9.82 2.78 2.96 0.07 1.72 7.24 7.84 9.23 1.71 6.24 5.78 5.37 0.03 9.60 8.86 2.73 5.83 6.50'
# a = s.split()
# print (D(min(a)) + D(max(a)))


# from decimal import Decimal as Dcm
#
# s = '0.77 4.03 9.06 3.80 7.08 5.88 0.23 4.65 2.79 0.90 4.23 2.15 3.24 8.57 0.10 8.57 1.49 5.64 3.63 8.36 1.56 6.67 1.46 5.26 4.83 7.23 1.22 1.02 7.82 9.97 5.40 9.79 9.82 2.78 2.96 0.07 1.72 7.24 7.84 9.23 1.71 6.24 5.78 5.37 0.03 9.60 8.86 2.73 5.83 6.50'
# print(Dcm(max(s.split(), key=Dcm)) + Dcm(min(s.split(), key=Dcm)))


# from decimal import Decimal
# s = '0.77 4.03 9.06 3.80 7.08 5.88 0.23 4.65 2.79 0.90 4.23 2.15 3.24 8.57 0.10 8.57 1.49 5.64 3.63 8.36 1.56 6.67 1.46 5.26 4.83 7.23 1.22 1.02 7.82 9.97 5.40 9.79 9.82 2.78 2.96 0.07 1.72 7.24 7.84 9.23 1.71 6.24 5.78 5.37 0.03 9.60 8.86 2.73 5.83 6.50'
# l = [*map(Decimal, s.split())]
# print(min(l) + max(l))


# from decimal import *
#
# s = '0.77 4.03 9.06 3.80 7.08 5.88 0.23 4.65 2.79 0.90 4.23 2.15 3.24 8.57 0.10 8.57 1.49 5.64 3.63 8.36 1.56 6.67 1.46 5.26 4.83 7.23 1.22 1.02 7.82 9.97 5.40 9.79 9.82 2.78 2.96 0.07 1.72 7.24 7.84 9.23 1.71 6.24 5.78 5.37 0.03 9.60 8.86 2.73 5.83 6.50'
#
# numbers = [Decimal(num) for num in s.split()]
# print(max(numbers) + min(numbers))

'''Decimal числа, разделенные символом пробела, хранятся в строковой переменной s. Дополните приведенный код, чтобы 
он вывел на первой строке сумму всех чисел, а на второй строке 55 самых больших чисел в порядке убывания, разделенных 
символом пробела.'''

# from decimal import Decimal
# s = '9.73 8.84 8.92 9.60 9.32 8.97 8.53 1.26 6.62 9.85 1.85 1.80 0.83 6.75 9.74 9.11 9.14 5.03 5.03 1.34 3.52 8.09 ' \
#     '7.89 8.24 8.23 5.22 0.30 2.59 1.25 6.24 2.14 7.54 5.72 2.75 2.32 2.69 9.32 8.11 4.53 0.80 0.08 9.36 5.22 4.08' \
#     ' 3.86 5.56 1.43 8.36 6.29 5.13'
#
# l = [*map(Decimal, s.split())]
# sortd=sorted(l,reverse=True)
# print(sum(l))
# print(*sortd[:5])

# from decimal import Decimal as D
#
# s = '9.73 8.84 8.92 9.60 9.32 8.97 8.53 1.26 6.62 9.85 1.85 1.80 0.83 6.75 9.74 9.11 9.14 5.03 5.03 1.34 3.52 8.09 7.89 8.24 8.23 5.22 0.30 2.59 1.25 6.24 2.14 7.54 5.72 2.75 2.32 2.69 9.32 8.11 4.53 0.80 0.08 9.36 5.22 4.08 3.86 5.56 1.43 8.36 6.29 5.13'
#
# nums = [D(x) for x in s.split()]
#
# print(sum(nums))
# print(*sorted(nums, reverse=True)[:5])


# from decimal import *
# s = '9.73 8.84 8.92 9.60 9.32 8.97 8.53 1.26 6.62 9.85 1.85 1.80 0.83 6.75 9.74 9.11 9.14 5.03 5.03 1.34 3.52 8.09 7.89 8.24 8.23 5.22 0.30 2.59 1.25 6.24 2.14 7.54 5.72 2.75 2.32 2.69 9.32 8.11 4.53 0.80 0.08 9.36 5.22 4.08 3.86 5.56 1.43 8.36 6.29 5.13'
# li = [Decimal(i) for i in s.split()]
# print(sum(li))
# print(*sorted(li, reverse = True)[:5])


# s = '9.73 8.84 8.92 9.60 9.32 8.97 8.53 1.26 6.62 9.85 1.85 1.80 0.83 6.75 9.74 9.11 9.14 5.03 5.03 1.34 3.52 8.09 7.89 8.24 8.23 5.22 0.30 2.59 1.25 6.24 2.14 7.54 5.72 2.75 2.32 2.69 9.32 8.11 4.53 0.80 0.08 9.36 5.22 4.08 3.86 5.56 1.43 8.36 6.29 5.13'
#
# from decimal import *
# s2 = [Decimal(x) for x in s.split()]
# print(sum(s2))
# print(*sorted(s2, reverse=True)[:5])


'''Дополните приведенный код, чтобы он вывел сумму наибольшей и наименьшей цифры Decimal числа.

Подсказка
Для отладки кода 🟡
Sample Input 1:

12.1244354689
Sample Output 1:

10'''
#
# from decimal import *
# num = Decimal(input())
# num_tuple = num.as_tuple()
# print(max(num_tuple.digits)+min(num_tuple.digits))


# from decimal import Decimal
# Dec = Decimal(input()).as_tuple().digits
# print(max(Dec) + min(Dec))

# s = input()
# mi = 9; ma = 0
# for e in s:
#     if e in "0123456789":
#         mi = min(mi, int(e))
#         ma = max(ma, int(e))
# print(ma + mi)


'''Математическое выражение
На вход программе подается Decimal число dd. Напишите программу, которая вычисляет значение выражения:
e^{d} + ln(d) + lg (d) + sqrt{d}

 

Формат входных данных
На вход программе подается положительное десятичное число d.

Формат выходных данных
Программа должна вывести искомое значение выражения.

Подсказка
Sample Input 1:

1.1
Sample Output 1:

4.189677737079134559844013562'''


# from decimal import Decimal
#
# d = Decimal(input())
# ch = d.exp() + d.ln() + d.log10() + d.sqrt()
# print(ch)

#
# from decimal import Decimal as D
# d = D(input())
# print(sum(func() for func in (d.exp, d.ln, d.log10, d.sqrt)))


# from decimal import *
# n = Decimal(input())
# print(n.exp()+n.ln()+n.log10()+n.sqrt())
